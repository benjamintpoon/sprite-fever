<!-- canvas.html -->

<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Canvas Test</title>
</head>
<style>
	* {
		margin: 0;
		padding: 0;
		border: 0;
	}
	body {
		background-color: #444;
	}
	.container {
		padding: 30px;
	}
	#canvas {
		border: 1px dotted #000;
		/*margin: 30px;*/
		float: left;
	}
	#color-picker {
		float: left;
		border: 1px solid #ccc;
		padding: 10px;
	}
	#color-map {
		background-image: url('map-saturation.png');
		height: 255px;
		width: 270px;
	}
	#swatch-container {
		margin: 0;
		font-size: 0; /*hack to remove space between swatches*/
	}
	.swatch {
		display: inline-block;
		height: 30px;
		width: 30px;
		background-color: blue;
	}
</style>
<body>
	<div class="container">
		<canvas id="canvas"></canvas>

		<div id="color-picker">
			<canvas id="color-picker-canvas"></canvas>
			<div id="swatch-container">
				<div class="swatch swatch-0"></div>
				<div class="swatch swatch-1"></div>
				<div class="swatch swatch-2"></div>
				<div class="swatch swatch-3"></div>
				<div class="swatch swatch-4"></div>
				<div class="swatch swatch-5"></div>
				<div class="swatch swatch-6"></div>
				<div class="swatch swatch-7"></div>
				<div class="swatch swatch-8"></div>
			</div>
		</div>
	</div>
	<script type="text/javascript" src="jquery-1.11.1.min.js"></script>
	<script type="text/javascript">

	// adjust this stuff..
		const TILE_SIZE = 30;
		const GRID_X = 16;
		const GRID_Y = 20;
		const NUM_SWATCHES = 9;
		const SWATCH_LIGHTNESS_STEP = Math.ceil(255 / NUM_SWATCHES); //29 for 9 swatches;

		var canvas = document.getElementById("canvas");
		var canvasCTX    = canvas.getContext("2d");
		canvas.width = TILE_SIZE * GRID_X;
		canvas.height = TILE_SIZE * GRID_Y;
		
		var colorPicker = document.getElementById("color-picker-canvas");
		var colorPickerCTX = colorPicker.getContext("2d");
		colorPicker.width = 270;
		colorPicker.height = 255;

		var colorMap = new Image();
		colorMap.onload = function() {
			colorPickerCTX.drawImage(colorMap, 0, 0, colorPicker.width, colorPicker.height);
		};
		colorMap.crossOrigin = "anonymous";
		colorMap.src = "http://localhost:8000/map-saturation.png";

		var colorPickerData = colorPickerCTX.getImageData(0, 0, colorPicker.width, colorPicker.height);

		const LIGHT_GREY  = 'rgba(200, 200, 200, 1)';
		const WHITE = 'rgba(255, 255, 255, 1)';
		const GRID_BG_COLORS = [LIGHT_GREY, WHITE];

		var selectedColor = 'rgba(0,0,0,1)';
		var colorCounter = 0;

		function Grid(width, height) {
			this.width = width;
			this.height = height;
			this.tiles = {};
		}

		Grid.prototype.initialize = function() {
			for (var r = 0; r < this.height; r++) {
				this.tiles[r] = {};
				for (var c = 0; c < this.width; c++) {
					this.tiles[r][c] = new Tile(c, r, GRID_BG_COLORS[(c + r) % 2]);
					this.tiles[r][c].render();
				}
			}
		}

		function Tile(x, y, color) {
			this.x = x;
			this.y = y;
			this.color = color || null;
		}

		Tile.prototype.render = function() {
			canvasCTX.fillStyle = this.color;
			canvasCTX.fillRect(
				this.x * TILE_SIZE, 
				this.y * TILE_SIZE, 
				TILE_SIZE, 
				TILE_SIZE);
		};
 	
		var Grid = new Grid(GRID_X, GRID_Y);
		Grid.initialize();

		$(function(){

			var $grid = $("#canvas");

			$grid.on('mousedown', function(e) {
				e.preventDefault();

				var gridX = Math.floor((e.offsetX - 1)/ TILE_SIZE);
				var gridY = Math.floor((e.offsetY - 1)/ TILE_SIZE);

				var tile = Grid.tiles[gridY][gridX];
				tile.color = selectedColor;
				tile.render();

				$(this).on('mousemove', function(e) {
					e.preventDefault();

					var lastX = gridX;
					var lastY = gridY;

					var gridX = Math.floor((e.offsetX - 1)/ TILE_SIZE);
					var gridY = Math.floor((e.offsetY - 1)/ TILE_SIZE);

					if (gridX !== lastX || gridY !== lastY) {
						var tile = Grid.tiles[gridY][gridX];
						tile.color = selectedColor;
						tile.render();
					}

					// shoudl i keep this or no?
					// maybe i wnat people to go off the edge and then
					// fill a bunch of tiles in ... who knows? testing!
					$(this).on('mouseout', function(e) {
						$(this).unbind('mousemove');
					});

					$(this).on('mouseup', function(e) {
						$(this).unbind('mousemove');
					});
				});
			}); // end mousedown

			$('.swatch').on('click', function(e) {
				selectedColor = $(this).css('background-color');
			}); 

			$(colorPicker).on('click', function(e) {
				selectedColor = getPixelColor(e.offsetX, e.offsetY);
				updateSwatches();
			});
		});

		function getPixelColor(x, y) {
			var rgba = colorPickerCTX.getImageData(x, y, 1, 1).data;
			return "rgba("+rgba[0]+","+rgba[1]+","+rgba[2]+","+rgba[3]+")";
		}
		function rgbaLighten(str, mult) {
			// parse an 'rgba(r,g,b,a)' string
			// return an array of integers as strings;
			str = str.substring(5, str.length-1).split(',');
			// find the 0 color value and update;
			str[str.indexOf('0')] = mult * SWATCH_LIGHTNESS_STEP;
			// rebuild the rgba string
			// console.log(str);
			// console.log("rgba(" + str.join(',') + ")");
			return "rgba(" + str.join(',') + ")";

		}

		function updateSwatches() {
			// loop over numSwatches
			// concat class string
			// calculate the rgba code
			// update swatch bgcolor
				// find which rgb value is zero
				// increment by 255/9?
			var klass = ".swatch-";
			for (var i = 0; i < NUM_SWATCHES; i++) {
				var $swatch = $(klass + i);
				var newColor = rgbaLighten(selectedColor, i);
				$swatch.css('background-color', newColor);
			}
		}
	</script>
</body>
</html>